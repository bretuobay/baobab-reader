import { z } from "zod";
import { publicProcedure, router } from "../trpc";
import { PDFDocument } from "pdf-lib";
import { getEbookRepository, type Ebook } from "../../db"; // Correct path to db

// Helper function to parse PDF metadata and return a partial Ebook object
async function parsePdfToPartialEbook(
  base64Pdf: string,
  filename: string
): Promise<
  Omit<Ebook, "id" | "uploadedAt" | "tags" | "filePath" | "lastReadPage">
> {
  const pdfBytes = Buffer.from(base64Pdf, "base64");
  const pdfDoc = await PDFDocument.load(pdfBytes, {
    updateMetadata: false, // Conservatively update metadata
  });

  const getMetaString = (metaFunc: () => string | undefined): string | null => {
    try {
      const value = metaFunc();
      return value !== undefined && value.trim() !== "" ? value.trim() : null;
    } catch (error) {
      console.warn(
        `Warning: Could not extract metadata for ${filename}: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  };

  const getMetaDate = (metaDateFunc: () => Date | undefined): string | null => {
    try {
      const date = metaDateFunc();
      return date ? date.toISOString() : null;
    } catch (error) {
      console.warn(
        `Warning: Could not extract date metadata for ${filename}: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  };

  // Extract metadata that aligns with Ebook.metadata
  const extractedMetadata = {
    creator: getMetaString(() => pdfDoc.getCreator()),
    producer: getMetaString(() => pdfDoc.getProducer()),
    creationDate: getMetaDate(() => pdfDoc.getCreationDate()),
    modificationDate: getMetaDate(() => pdfDoc.getModificationDate()),
    subject: getMetaString(() => pdfDoc.getSubject()) || undefined,
    keywords:
      getMetaString(() => pdfDoc.getKeywords())
        ?.split(",")
        .map((k) => k.trim())
        .filter((k) => k) || undefined,
    // pdf-lib does not directly expose page count in a simple way without iterating,
    // so we'll omit it here or assume it's set later if needed.
    // pages: pdfDoc.getPageCount(), // This is available
  };

  return {
    filename,
    title: getMetaString(() => pdfDoc.getTitle()),
    author: getMetaString(() => pdfDoc.getAuthor()),
    metadata: extractedMetadata,
  };
}

export const pdfRouter = router({
  uploadPdf: publicProcedure
    .input(
      z.object({
        filename: z.string(),
        data: z.string() /* base64 encoded PDF */,
      })
    )
    .mutation(async ({ input }) => {
      let partialEbookData: Omit<
        Ebook,
        "id" | "uploadedAt" | "tags" | "filePath" | "lastReadPage"
      >;
      try {
        partialEbookData = await parsePdfToPartialEbook(
          input.data,
          input.filename
        );
      } catch (error) {
        console.error(
          `Error parsing PDF metadata for ${input.filename}: ${error instanceof Error ? error.message : String(error)}`
        );
        throw new Error("Failed to parse PDF metadata");
      }

      const ebookRepo = await getEbookRepository();

      // Construct the Ebook object for saving.
      // 'id' will be generated by the database.
      // 'uploadedAt' will be set by the database or repository.
      // Other fields like 'tags', 'filePath', 'lastReadPage' are not set at initial upload.
      const ebookToSave: Omit<Ebook, "id" | "uploadedAt"> = {
        ...partialEbookData,
        // Ensure all required fields in Ebook (even if partial) are present
        // filename, title, author are from partialEbookData
        // metadata is from partialEbookData
        // Optional fields like tags, filePath, lastReadPage can be omitted
      };

      try {
        // Type assertion needed because ebookToSave is Omit<Ebook, "id" | "uploadedAt">
        // but repository.save expects Ebook (or partial Ebook if id is optional for new ones)
        // The SqliteEbookRepository handles Ebook objects where 'id' might be missing for new entries.
        const savedEbook = await ebookRepo.save(ebookToSave as Ebook);
        return { success: true, ebook: savedEbook };
      } catch (error) {
        console.error(
          `Error saving Ebook metadata for ${input.filename}: ${error instanceof Error ? error.message : String(error)}`
        );
        // Consider more specific error handling or re-throwing a tRPC-compatible error
        throw new Error("Failed to save Ebook metadata to database.");
      }
    }),

  listPdfs: publicProcedure.query(async () => {
    const ebookRepo = await getEbookRepository();
    const ebooks = await ebookRepo.getAll();
    return ebooks;
  }),
});

export type PdfRouter = typeof pdfRouter;
