import { z } from "zod";
import { publicProcedure, router } from "../trpc";
import { PDFDocument } from "pdf-lib";
import { getEbookRepository, type Ebook } from "../../db"; // Correct path to db

// Helper function to parse PDF metadata and return a partial Ebook object
async function parsePdfToPartialEbook(
  base64Pdf: string,
  filename: string
): Promise<
  Omit<Ebook, "id" | "uploadedAt" | "tags" | "filePath" | "lastReadPage">
> {
  const pdfBytes = Buffer.from(base64Pdf, "base64");
  const pdfDoc = await PDFDocument.load(pdfBytes, {
    updateMetadata: false, // Conservatively update metadata
  });

  const getMetaString = (metaFunc: () => string | undefined): string | null => {
    try {
      const value = metaFunc();
      return value !== undefined && value.trim() !== "" ? value.trim() : null;
    } catch (error) {
      console.warn(
        `Warning: Could not extract metadata for ${filename}: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  };

  const getMetaDate = (metaDateFunc: () => Date | undefined): string | null => {
    try {
      const date = metaDateFunc();
      return date ? date.toISOString() : null;
    } catch (error) {
      console.warn(
        `Warning: Could not extract date metadata for ${filename}: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  };

  // Extract metadata that aligns with Ebook.metadata
  const extractedMetadata = {
    creator: getMetaString(() => pdfDoc.getCreator()),
    producer: getMetaString(() => pdfDoc.getProducer()),
    creationDate: getMetaDate(() => pdfDoc.getCreationDate()),
    modificationDate: getMetaDate(() => pdfDoc.getModificationDate()),
    subject: getMetaString(() => pdfDoc.getSubject()) || undefined,
    keywords:
      getMetaString(() => pdfDoc.getKeywords())
        ?.split(",")
        .map((k) => k.trim())
        .filter((k) => k) || undefined,
    // pdf-lib does not directly expose page count in a simple way without iterating,
    // so we'll omit it here or assume it's set later if needed.
    // pages: pdfDoc.getPageCount(), // This is available
  };

  return {
    filename,
    title: getMetaString(() => pdfDoc.getTitle()),
    author: getMetaString(() => pdfDoc.getAuthor()),
    metadata: extractedMetadata,
  };
}

export const pdfRouter = router({
  uploadPdf: publicProcedure
    .input(
      z.object({
        filename: z.string(),
        data: z.string() /* base64 encoded PDF */,
      })
    )
    .mutation(async ({ input }) => {
      let partialEbookData: Omit<
        Ebook,
        "id" | "uploadedAt" | "tags" | "filePath" | "lastReadPage"
      >;
      try {
        partialEbookData = await parsePdfToPartialEbook(
          input.data,
          input.filename
        );
      } catch (error) {
        console.error(
          `Error parsing PDF metadata for ${input.filename}: ${error instanceof Error ? error.message : String(error)}`
        );
        throw new Error("Failed to parse PDF metadata");
      }

      const ebookRepo = await getEbookRepository();

      // Construct the Ebook object for saving.
      // 'id' will be generated by the database.
      // 'uploadedAt' will be set by the database or repository.
      // Other fields like 'tags', 'filePath', 'lastReadPage' are not set at initial upload.
      const ebookToSave: Omit<Ebook, "id" | "uploadedAt"> = {
        ...partialEbookData,
        // Ensure all required fields in Ebook (even if partial) are present
        // filename, title, author are from partialEbookData
        // metadata is from partialEbookData
        // Optional fields like tags, filePath, lastReadPage can be omitted
      };

      try {
        // Type assertion needed because ebookToSave is Omit<Ebook, "id" | "uploadedAt">
        // but repository.save expects Ebook (or partial Ebook if id is optional for new ones)
        // The SqliteEbookRepository handles Ebook objects where 'id' might be missing for new entries.
        const savedEbook = await ebookRepo.save(ebookToSave as Ebook);
        return { success: true, ebook: savedEbook };
      } catch (error) {
        console.error(
          `Error saving Ebook metadata for ${input.filename}: ${error instanceof Error ? error.message : String(error)}`
        );
        // Consider more specific error handling or re-throwing a tRPC-compatible error
        throw new Error("Failed to save Ebook metadata to database.");
      }
    }),

  listPdfs: publicProcedure.query(async () => {
    const ebookRepo = await getEbookRepository();
    const ebooks = await ebookRepo.getAll();
    return ebooks;
  }),

  syncBookToSqlite: publicProcedure
    .input(
      z.object({
        id: z.string(), // UUID from IndexedDB
        title: z.string().nullable(),
        author: z.string().nullable(),
        filename: z.string(),
        tags: z.array(z.string()).optional().nullable(), // Making nullable too for flexibility
        filePath: z.string().optional().nullable(),
        metadata: z
          .object({
            subject: z.string().optional().nullable(),
            keywords: z.array(z.string()).optional().nullable(),
            pages: z.number().optional().nullable(),
            creator: z.string().optional().nullable(),
            producer: z.string().optional().nullable(),
            creationDate: z.string().optional().nullable(),
            modificationDate: z.string().optional().nullable(),
          })
          .optional()
          .nullable(),
        uploadedAt: z.string().optional().nullable(), // ISO date string
        lastReadPage: z.number().optional().nullable(),
        sqliteId: z.number().optional().nullable(),
        syncStatus: z
          .enum(["synced", "pending", "error"])
          .optional()
          .nullable(),
      })
    ) // Use the Zod schema for input validation
    .mutation(async ({ input }) => {
      const ebookRepo = await getEbookRepository();
      try {
        // The input 'input' is an Ebook object from the client.
        // The SqliteEbookRepository.save method is now designed to:
        // - Use input.sqliteId for updates if available.
        // - Use input.id (UUID) to check for existing records if sqliteId is not available.
        // - Insert new record if no existing one is found.
        // - It returns the Ebook object as it is in SQLite, with 'id' being the UUID
        //   and 'sqliteId' being the SQLite primary key.

        // Cast to Ebook as Zod's inferred type might be slightly different
        const savedEbook = await ebookRepo.save(input as Ebook);

        // The savedEbook should have the sqliteId populated by the save method.
        // It will also have syncStatus: 'synced' due to the sqliteToEbook mapper.
        return savedEbook;
      } catch (error) {
        console.error(
          `Error syncing Ebook (ID: ${input.id}, SQLiteID: ${
            input.sqliteId || "N/A"
          }) to SQLite: ${
            error instanceof Error ? error.message : String(error)
          }`
        );
        // For now, rethrowing generic error. Consider TRPCError for more specific client feedback.
        // import { TRPCError } from '@trpc/server';
        // throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to sync book with database.' });
        throw new Error("Failed to sync book with database.");
      }
    }),
});

export type PdfRouter = typeof pdfRouter;
